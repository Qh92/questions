## 一、java



#### 说一下ArrayList和LinkedList的区别？

```markdown
1.首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的
2.由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同
3.另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做双端队列来使用
```

#### ArrayList和LinkedList的插入和访问的时间复杂度？

```markdown
ArrayList 是线性表（数组）
get() 直接读取第几个下标，复杂度 O(1)
add(E) 添加元素，直接在后面添加，复杂度O（1）
add(index, E) 添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）
remove（object）删除元素，后面的元素需要逐个移动，复杂度O（n）

LinkedList 是链表的操作
get() 获取第几个元素，依次遍历，复杂度O(n)
add(E) 添加到末尾，复杂度O(1)
add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)
remove（object）删除元素，需要访问元素，复杂度O(n)
```

#### 说一下HashMap的put方法？

![1631848253569](assets\1631848253569.png)

```markdown
先说HashMap的put方法的大体流程：
1.根据Key通过哈希算法与与运算得出数组下标
2.如果数组下标位置为空，则将key和value封装为Entry对象（1.7及以前是Entry对象，1.8中是Node对象）并放入该位置
3.如果数组下标位置元素不为空，则要分情况讨论
	a.如果是jdk1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中
	b.如果是jdk1.8，则会先判断当前位置上的Node类型，看是红黑树Node,还是链表Node
		i.如果是红黑树Node,则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key,如果存在则更新vaLue
		ii.如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key,如果存在则更新value,当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数和当前数组的长度，如果数组长度超过了64并且链表的长度超过了8，那么则会将该链表转成红黑树
		iii.将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就直接完成插入
```

#### 为什么HashMap计算hash值时要将hashCode与hashCode无符号右移16位后做异或运算？

![img](assets\aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTg0NDIzLzIwMTkwNy85ODQ0MjMtMjAxOTA3MTgxMTM3MzczMzAtNjI1NzkxNTQxLnBuZw.png)

```markdown
将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原hashcode做异或运算，可以将高低位二进制特征混合起来

从上文可知高区的16位与原hashcode相比没有发生变化，低区的16位发生了变化

我们可知通过上面(h = key.hashCode()) ^ (h >>> 16)进行运算可以把高区与低区的二进制特征混合到低区，那么为什么要这么做呢？

我们都知道重新计算出的新哈希值在后面将会参与hashmap中数组槽位的计算，计算公式：(n - 1) & hash，假如这时数组槽位有16个，则槽位计算如下：
```

![img](assets\aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTg0NDIzLzIwMTkwNy85ODQ0MjMtMjAxOTA3MTgxMTQyNTU1NzAtMTA1MzA2NDg5Ny5wbmc.png)

```markdown
仔细观察上文不难发现，高区的16位很有可能会被数组槽位数的二进制码锁屏蔽，如果我们不做刚才移位异或运算，那么在计算槽位时将丢失高区特征

也许你可能会说，即使丢失了高区特征不同hashcode也可以计算出不同的槽位来，但是细想当两个哈希码很接近时，那么这高区的一点点差异就可能导致一次哈希碰撞，所以这也是将性能做到极致的一种体现
保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞
```

异或运算能更好的保留各部分的特征，如果采用 **& 运算计算出来的值会向0靠拢，采用 | 运算计算出来的值会向1靠拢**

#### 为什么槽位数必须使用2^n (重点)

为了让哈希后的结果更加均匀，最终目的还是为了让哈希后的结果更均匀的分部，减少哈希碰撞，提升hashmap的运行效率

#### HashMap在什么情况下会扩容，或者有哪些操作会导致扩容？

#### HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？

#### 1.8还采用了红黑树，讲讲红黑树的特性，为什么人家一定要用红黑树而不是AVL、B树之类的？

```markdown
红黑树的特性：
1.根结点和叶子结点都是黑色的
2.中间的结点要么是黑色要么是红色
3.红色的结点不能连续
4.任意结点到其叶子结点的所有路径中的黑色结点个数相等

红黑树是弱平衡树，AVL树是强平衡树，如果采用AVL树有可能导致树经常旋转平衡，影响性能
B树是多路查找树，B树的每个结点都有可能存储数据，极端情况下，B树的数据存储会变成链表，进而影响查询的性能
```



#### 说一下ThreadLocal

![1631863253318](E:\item\questions\java\doc\assets\1631863253318.png)

![1631865581803](assets\1631865581803.png)

```markdown
1.ThreadLocal是java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据
2.ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值
3.如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key,value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象
4.ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接）
```



#### 说一下JVM中，哪些是共享区，哪些可以作为gc root

![1631865952400](assets\1631865952400.png)

```markdown
1.堆区和方法区是所有栈线程共享的，虚拟机栈、本地方法栈、程序计数器是每个线程独有的
2.什么是gc root,JVM在进行垃圾回收时，需要找到"垃圾"对象，也就是没有被引用的对象，但是直接找"垃圾"对象是比较耗时的，所以反过来，先找"非垃圾"对象，也就是正常对象，那么就需要从某些"根"开始去找，根据这些"根"的引用路径找到正常对象，而这些"根"有一个特征，就是它只会引用其它对象，而不会被其它对象引用。例如：虚拟机栈和本地方法栈中局部变量所引用的对象，方法区中的静态变量所引用的对象和常量所引用的对象，synchronized所持有的对象，一些常驻的异常对象等等
```



#### 你们项目如何排查JVM问题？

![1631871209490](assets\1631871209490.png)



#### 如何查看线程死锁？

![1631872358903](assets\1631872358903.png)



#### 线程之间如何进行通讯的？

![1631872470499](assets\1631872470499.png)

```markdown
1.线程之间可以通过共享内存或基于网络来进行通信
2.如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒
3.像java中的wait()、notify()就是阻塞和唤醒
4.通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式
```



#### 介绍一下Spring,读过源码介绍一下大致流程

![image-20210917231909768](assets\image-20210917231909768.png)



#### 说一下Spring的事务机制

![image-20210917232530729](assets\image-20210917232530729.png)

```markdown
1.Spring事务底层是基于数据库事务和AOP机制的
2.首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean
3.当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解
4.如果加了，那么则利用事务管理器创建一个数据库连接
5.并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步
6.然后执行当前方法，方法中会执行sql
7.执行完当前方法后，如果没有出现异常就直接提交事务
8.如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务
9.Spring事务的隔离级别对应的就是数据库的隔离级别
10.Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的
11.Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql
```



#### 什么时候@Transactional失效？

![image-20210917234016470](assets\image-20210917234016470.png)

```markdown
1.因为Spring事务是基于代理来实现的，所以某个加了@Transactional的方法只有是被代理对象调用时，那么这个注解才会生效，所以如果是被代理对象来调用这个方法，那么@Transactional是不会生效的
2.同时如果某个方法是private的，那么@Transactional也会失效，因为底层cglib是基于父类来实现的，子类是不能重写父类的private方法的，所以无法很好的利用代理，也会导致@Transactional失效
```



#### Dubbo是如何做系统交互的？

![1631935035070](assets\1631935035070.png)





#### Dubbo的负载均衡策略

![1631935336361](assets\1631935336361.png)

https://www.yuque.com/renyong-jmovm/kb/gwu187



#### JDK1.7到JDK1.8 HashMap发生了什么变化（底层）？

![1631935713169](assets\1631935713169.png)

```markdown
1. 1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率
2. 1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计表元素个数，所以正好就直接使用尾插法
3. 1.7中hash算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为负载的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源
```



#### JDK1.7到JDK1.8 java虚拟机发生了什么变化？

![1631948247443](assets\1631948247443.png)

```markdown
1.7中存在永久代，1.8中没有永久代，替换它的是元空间，元空间所占的内存不是在虚拟机内部，而是本地内存空间，这么做的原因是，不管是永久代还是元空间，他们都是方法区的具体实现，之所以元空间所占的内存改成本地内存，官方的说法是为了和JRockit统一，不过额外还有一些原因，比如方法区所存储的类信息通常是比较难确定的，所以对于方法区的大小是比较难指定的，太小了容易出现方法区溢出，太大了又会占用太对虚拟机的内存空间，而转移到本地内存后则不会影响虚拟机所占用的内存
```





#### 如何实现AOP,项目哪些地方用到了AOP?

![1631950567681](assets\1631950567681.png)

```markdown
利用动态代理技术来实现AOP，比如JDK动态代理或Cglib动态代理，利用动态代理技术，可以针对某个类生成代理对象，当调用代理对象的某个方法时，可以任意控制该方法的执行，比如可以先打印执行时间，再执行该方法，并且该方法执行完成后，再次打印执行时间。项目中，比如事务、权限控制、方法执行日志都是通过AOP技术来实现的，凡是需要对某些方法做统一处理的都可以用AOP来实现，利用AOP可以做到业务无侵入
```



#### Spring中后置处理器的作用？

![1631951203427](assets\1631951203427.png)

```markdown
Spring中的后置处理器分为BeanFactory后置处理器和Bean后置处理器，它们是Spring底层源码架构设计中非常重要的一种机制，同时开发者也可以利用这两种后置处理器来进行扩展。BeanFactory后置处理器表示针对BeanFactory的处理器，Spring启动过程中，会先创建出BeanFactory实例，然后利用BeanFactory处理器来加工BeanFactory，比如Spring的扫描就是基于BeanFactory后置处理器来实现的。而Bean后置处理器也类似，Spring在创建一个Bean的过程中，首先会实例化得到一个对象，然后再利用Bean后置处理器来对该实例对象进行加工，比如我们常说的依赖注入就是基于一个Bean后置处理器来实现的，通过该Bean后置处理器来给实例对象中加了@Autowired注解的属性自动赋值，还比如我们常说的AOP，也是利用一个Bean后置处理器来实现的，基于原实例对象，判断是否需要进行AOP，如果需要，那么就基于原实例对象进行动态代理，生成一个代理对象
```



#### 说说常用的SpringBoot注解及其实现

![1631953376727](assets\1631953376727.png)



#### 说说你了解的分布式锁实现

![1631953699163](assets\1631953699163.png)



#### Redis的数据结构及使用场景

![1631955850691](assets\1631955850691.png)



#### Redis集群策略

![1631956055132](assets\1631956055132.png)



#### MySQL数据库中，什么情况下设置了索引但无法使用？

![1631956714675](assets\1631956714675.png)

```markdown
1. 如果索引是复合索引，没有符合最左前缀原则，什么是最左前缀原则，就是复合索引列的第一列必须使用
2. 索引列字段进行了隐式数据类型转换
3. 索引列使用了like进行查询，并且%通配符放在了最前面
4. 索引列使用了or进行了查询，但是or前后只有一个列是索引。使用or查询时，只有前后两列都是索引列才能使用索引，其它情况都不能使用索引
```



#### Innodb是如何实现事务的？

![1631957264442](assets\1631957264442.png)



#### 聊聊你最有成就感的项目？自己最有挑战的项目、难点

![1631957502373](assets\1631957502373.png)



#### 遇到过哪些设计模式？

![image-20210918225533503](assets\image-20210918225533503.png)



#### Java死锁如何避免？

![image-20210918230300142](assets\image-20210918230300142.png)



#### 深拷贝和浅拷贝

![image-20210918230508143](assets\image-20210918230508143.png)



#### 如果你提交任务时，线程池队列已满，这时会发生什么？

![image-20210918230656195](assets\image-20210918230656195.png)



#### 谈谈ConcurrentHashMap的扩容机制

![image-20210918231044908](assets\image-20210918231044908.png)



#### Spring中Bean是线程安全的吗?

![image-20210918231245294](assets\image-20210918231245294.png)



#### 说说你常用的Linux基本操作命令

![image-20210918232942619](assets\image-20210918232942619.png)



#### Maven中的Package和Install的区别

![image-20210918233031685](assets\image-20210918233031685.png)





#### SpringCloud各组件功能，与Dubbo的区别

![image-20210918233247820](assets\image-20210918233247820.png)



#### 项目及主要负责的模块

![image-20210918233428566](assets\image-20210918233428566.png)



#### 遇到过哪些设计模式？

![1632304310790](assets\1632304310790.png)



#### Java死锁如何避免？

![1632304436603](assets\1632304436603.png)





