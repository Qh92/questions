## 一、java



#### 说一下ArrayList和LinkedList的区别？

```markdown
1.首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的
2.由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同
3.另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做双端队列来使用
```

#### ArrayList和LinkedList的插入和访问的时间复杂度？

```markdown
ArrayList 是线性表（数组）
get() 直接读取第几个下标，复杂度 O(1)
add(E) 添加元素，直接在后面添加，复杂度O（1）
add(index, E) 添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）
remove（object）删除元素，后面的元素需要逐个移动，复杂度O（n）

LinkedList 是链表的操作
get() 获取第几个元素，依次遍历，复杂度O(n)
add(E) 添加到末尾，复杂度O(1)
add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)
remove（object）删除元素，需要访问元素，复杂度O(n)
```

#### 说一下HashMap的put方法？

![1631848253569](assets\1631848253569.png)

```markdown
先说HashMap的put方法的大体流程：
1.根据Key通过哈希算法与与运算得出数组下标
2.如果数组下标位置为空，则将key和value封装为Entry对象（1.7及以前是Entry对象，1.8中是Node对象）并放入该位置
3.如果数组下标位置元素不为空，则要分情况讨论
	a.如果是jdk1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中
	b.如果是jdk1.8，则会先判断当前位置上的Node类型，看是红黑树Node,还是链表Node
		i.如果是红黑树Node,则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key,如果存在则更新vaLue
		ii.如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key,如果存在则更新value,当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数和当前数组的长度，如果数组长度超过了64并且链表的长度超过了8，那么则会将该链表转成红黑树
		iii.将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就直接完成插入
```

#### 为什么HashMap计算hash值时要将hashCode与hashCode无符号右移16位后做异或运算？

![img](assets\aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTg0NDIzLzIwMTkwNy85ODQ0MjMtMjAxOTA3MTgxMTM3MzczMzAtNjI1NzkxNTQxLnBuZw.png)

```markdown
将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原hashcode做异或运算，可以将高低位二进制特征混合起来

从上文可知高区的16位与原hashcode相比没有发生变化，低区的16位发生了变化

我们可知通过上面(h = key.hashCode()) ^ (h >>> 16)进行运算可以把高区与低区的二进制特征混合到低区，那么为什么要这么做呢？

我们都知道重新计算出的新哈希值在后面将会参与hashmap中数组槽位的计算，计算公式：(n - 1) & hash，假如这时数组槽位有16个，则槽位计算如下：
```

![img](assets\aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTg0NDIzLzIwMTkwNy85ODQ0MjMtMjAxOTA3MTgxMTQyNTU1NzAtMTA1MzA2NDg5Ny5wbmc.png)

```markdown
仔细观察上文不难发现，高区的16位很有可能会被数组槽位数的二进制码锁屏蔽，如果我们不做刚才移位异或运算，那么在计算槽位时将丢失高区特征

也许你可能会说，即使丢失了高区特征不同hashcode也可以计算出不同的槽位来，但是细想当两个哈希码很接近时，那么这高区的一点点差异就可能导致一次哈希碰撞，所以这也是将性能做到极致的一种体现
```

异或运算能更好的保留各部分的特征，如果采用&运算计算出来的值会向0靠拢，采用|运算计算出来的值会向1靠拢

为什么槽位数必须使用2^n (重点)

为了让哈希后的结果更加均匀，最终目的还是为了让哈希后的结果更均匀的分部，减少哈希碰撞，提升hashmap的运行效率

#### HashMap在什么情况下会扩容，或者有哪些操作会导致扩容？

#### HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？

#### 1.8还采用了红黑树，讲讲红黑树的特性，为什么人家一定要用红黑树而不是AVL、B树之类的？

#### 说一下ThreadLocal

![1631863253318](E:\item\questions\java\doc\assets\1631863253318.png)

![1631865581803](assets\1631865581803.png)

```markdown
1.ThreadLocal是java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据
2.ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值
3.如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key,value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象
4.ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接）
```



#### 说一下JVM中，哪些是共享区，哪些可以作为gc root

![1631865952400](assets\1631865952400.png)

```markdown
1.堆区和方法区是所有栈线程共享的，虚拟机栈、本地方法栈、程序计数器是每个线程独有的
2.什么是gc root,JVM在进行垃圾回收时，需要找到"垃圾"对象，也就是没有被引用的对象，但是直接找"垃圾"对象是比较耗时的，所以反过来，先找"非垃圾"对象，也就是正常对象，那么就需要从某些"根"开始去找，根据这些"根"的引用路径找到正常对象，而这些"根"有一个特征，就是它只会引用其它对象，而不会被其它对象引用。例如：虚拟机栈和本地方法栈中局部变量所引用的对象，方法区中的静态变量所引用的对象和常量所引用的对象，synchronized所持有的对象，一些常驻的异常对象等等
```



#### 你们项目如何排查JVM问题？

![1631871209490](assets\1631871209490.png)



#### 如何查看线程死锁？

![1631872358903](assets\1631872358903.png)



#### 线程之间如何进行通讯的？

![1631872470499](assets\1631872470499.png)

```markdown
1.线程之间可以通过共享内存或基于网络来进行通信
2.如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒
3.像java中的wait()、notify()就是阻塞和唤醒
4.通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式
```



#### 介绍一下Spring,读过源码介绍一下大致流程

![image-20210917231909768](assets\image-20210917231909768.png)



#### 说一下Spring的事务机制

![image-20210917232530729](assets\image-20210917232530729.png)

```markdown
1.Spring事务底层是基于数据库事务和AOP机制的
2.首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean
3.当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解
4.如果加了，那么则利用事务管理器创建一个数据库连接
5.并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步
6.然后执行当前方法，方法中会执行sql
7.执行完当前方法后，如果没有出现异常就直接提交事务
8.如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务
9.Spring事务的隔离级别对应的就是数据库的隔离级别
10.Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的
11.Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql
```



#### 什么时候@Transactional失效？

![image-20210917234016470](assets\image-20210917234016470.png)